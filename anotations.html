<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HR8J8853HV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HR8J8853HV');
</script>
<body>

    <div class="annotation">        
        <p>
            <strong>Cube</strong>
            In geometry, a cube is a three-dimensional solid object bounded by six square faces, facets or sides, with three meeting at each vertex.
        </p>
    </div>
    <canvas id="number"></canvas>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('three-js.html');">Back</button>
    </div>

    <script src="./assets/js/jquery.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const container = document.getElementById('container');
        const annotation = document.querySelector(".annotation");
        let cube, scene, camera, renderer, sprite, mesh, spriteBehindObject, controls;

        const canvas = document.getElementById("number");
        const ctx = canvas.getContext("2d");
        const x = 32;
        const y = 32;
        const radius = 30;
        const startAngle = 0;
        const endAngle = Math.PI * 2;

        ctx.fillStyle = "rgb(0, 0, 0)";
        ctx.beginPath();
        ctx.arc(x, y, radius, startAngle, endAngle);
        ctx.fill();

        ctx.strokeStyle = "rgb(255, 255, 255)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, radius, startAngle, endAngle);
        ctx.stroke();

        ctx.fillStyle = "rgb(255, 255, 255)";
        ctx.font = "32px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("1", x, y);

        init().then(animate);

        async function init(){
            
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 2, 3000);
            camera.position.set(400, 400, 400);

            scene = new THREE.Scene();
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor(0xfb2470, 1);
            container.appendChild( renderer.domElement );

            const lights = [];
            lights[0] = new THREE.PointLight(0xffffff, 1, 0);
            //lights[1] = new THREE.PointLight(0xffffff, 1, 0);
            //lights[2] = new THREE.PointLight(0xffffff, 1, 0);

            lights[0].position.set(0, 2, 0);
            //lights[1].position.set(1000, 2000, 1000);
            //lights[2].position.set(-1000, -2000, -1000);

            scene.add(lights[0]);
            //scene.add(lights[1]);
            //scene.add(lights[2]);
            
            const cubeGeometry = new THREE.BoxGeometry(500, 500, 500);

            mesh = new THREE.Mesh(
                cubeGeometry,
                new THREE.MeshPhongMaterial({
                    color: 0x553699, // 0xfb1270,
                    emissive: 0xfb1170,
                    side: THREE.DoubleSide,
                    shading: THREE.FlatShading
                })
            );

            const line = new THREE.LineSegments(
                new THREE.WireframeGeometry(cubeGeometry),
                new THREE.LineBasicMaterial({
                    color: 0xff55ac, //0xfb9490,
                    linewidth: 1,
                    opacity: 1,
                    transparent: true
                })
            );

            scene.add(mesh);
            scene.add(line);

            const numberTexture = new THREE.CanvasTexture( document.querySelector("#number") );

            const spriteMaterial = new THREE.SpriteMaterial({
                map: numberTexture,
                alphaTest: 1,
                transparent: true,
                depthTest: true,
                depthWrite: false
            });

            sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(250, 250, 250);
            sprite.scale.set(6, 60, 1);

            scene.add(sprite);

            controls = new OrbitControls(camera, renderer.domElement);
            //controls.enableZoom = false;
            //controls.enableDamping = true;
            //controls.minDistance = 2;
            //controls.maxDistance = 4;
            //controls.target.set(0,0,0);
            //controls.enablePan = false;
            controls.update();

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }

        function render() {
            renderer.render(scene, camera);
            updateAnnotationOpacity();
            updateScreenPosition();
        }

        function updateAnnotationOpacity() {
            const meshDistance = camera.position.distanceTo(mesh.position);
            const spriteDistance = camera.position.distanceTo(sprite.position);
            spriteBehindObject = spriteDistance > meshDistance;
            sprite.material.opacity = spriteBehindObject ? 0.25 : 1;

            // Do you want a number that changes size according to its position?
            // Comment out the following line and the `::before` pseudo-element.
            sprite.material.opacity = 1;
        }

        function updateScreenPosition() {
            const vector = new THREE.Vector3(250, 250, 250);
            const canvas = renderer.domElement;

            vector.project(camera);

            vector.x = Math.round((0.5 + vector.x / 2) * (canvas.width / window.devicePixelRatio));
            vector.y = Math.round((0.5 - vector.y / 2) * (canvas.height / window.devicePixelRatio));

            annotation.style.top = `${vector.y}px`;
            annotation.style.left = `${vector.x}px`;
            annotation.style.opacity = spriteBehindObject ? 0.25 : 1;
        }
    </script>

</body>
</html>
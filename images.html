<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
    <style>
        canvas{
            background: linear-gradient(to bottom, #412f50 0%,#131837 100%);
        }
    </style>
</head>
<body>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('threejs.html');">Back</button>
    </div>

    <script id="fragmentShader" type="x-shader/x-fragment">

        uniform float time;

        uniform float fogDensity;
        uniform vec3 fogColor;

        uniform sampler2D texture1;
        uniform sampler2D texture2;

        varying vec2 vUv;

        void main( void ) {

            vec2 position = - 1.0 + 2.0 * vUv;

            vec4 noise = texture2D( texture1, vUv );
            vec2 T1 = vUv + vec2( 1.5, - 1.5 ) * time * 0.02;
            vec2 T2 = vUv + vec2( - 0.5, 2.0 ) * time * 0.01;

            T1.x += noise.x * 2.0;
            T1.y += noise.y * 2.0;
            T2.x -= noise.y * 0.2;
            T2.y += noise.z * 0.2;

            float p = texture2D( texture1, T1 * 2.0 ).a;

            vec4 color = texture2D( texture2, T2 * 2.0 );
            vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );

            if( temp.r > 1.0 ) { temp.bg += clamp( temp.r - 2.0, 0.0, 100.0 ); }
            if( temp.g > 1.0 ) { temp.rb += temp.g - 1.0; }
            if( temp.b > 1.0 ) { temp.rg += temp.b - 1.0; }

            gl_FragColor = temp;

            float depth = gl_FragCoord.z / gl_FragCoord.w;
            const float LOG2 = 1.442695;
            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );
            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );

            gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

        }

    </script>

    <script id="vertexShader" type="x-shader/x-vertex">

        uniform vec2 uvScale;
        varying vec2 vUv;

        void main()
        {

            vUv = uvScale * uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;

        }

    </script>

    <script src="./assets/js/jquery.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        //import { OrbitControls } from 'three/addons/controls/OrbitControls.js';        
        //import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        //import { TWEEN } from 'three/addons/libs/tween.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';

        const container = document.getElementById('container');
        let camera, controls, scene, renderer, loader, composer, clock, uniforms, mesh;

        init();

        function init(){
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.z = 4;

            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight ); // renderer.setAnimationLoop( render );
            //renderer.shadowMap.enabled = true;
            renderer.autoClear = false;
            container.appendChild( renderer.domElement );

            uniforms = {
                'fogDensity': { value: 0.45 },
                'fogColor': { value: new THREE.Vector3( 0, 0, 0 ) },
                'time': { value: 1.0 },
                'uvScale': { value: new THREE.Vector2( 3.0, 1.0 ) },
                'texture1': { value: new THREE.TextureLoader().load( './assets/media/lava/cloud.png' ) },
                'texture2': { value: new THREE.TextureLoader().load( './assets/media/lava/lavatile.jpg' ) }
            };

            uniforms[ 'texture1' ].value.wrapS = uniforms[ 'texture1' ].value.wrapT = THREE.RepeatWrapping;
			uniforms[ 'texture2' ].value.wrapS = uniforms[ 'texture2' ].value.wrapT = THREE.RepeatWrapping;

            const size = 0.23;

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent
            });

            mesh = new THREE.Mesh( new THREE.SphereGeometry( 1.5, 64, 128 ), material );
            mesh.rotation.x = 0.3;
            scene.add( mesh );

            const renderModel = new RenderPass( scene, camera );
            const effectBloom = new BloomPass( 1.25 );
            const effectFilm = new FilmPass( 0.35, 0.95, 2048, false );

            composer = new EffectComposer( renderer );

            composer.addPass( renderModel );
            composer.addPass( effectBloom );
            composer.addPass( effectFilm );

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            renderer.setSize( window.innerWidth, window.innerHeight );
			composer.setSize( window.innerWidth, window.innerHeight );

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            animate();
        }
        
        function animate() {
            requestAnimationFrame( animate );
            const delta = 5 * clock.getDelta();

            uniforms[ 'time' ].value += 0.2 * delta;

            //mesh.rotation.y += 0.0125 * delta;
            //mesh.rotation.x += 0.05 * delta;

            renderer.clear();
            composer.render( 0.01 );
            
            renderer.render( scene, camera );
        }
        
        animate();

    </script>

</body>
</html>
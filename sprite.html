<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<body>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('threejs.html');">Back</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let container = document.getElementById( 'container' );
        let camera, scene, renderer, controls, cameraOrtho;
        let currentTile, annie, mouse = new THREE.Vector2(), runner, sceneOrtho, material, runnerTexture;
        var clock = new THREE.Clock();
        const width = window.innerWidth;
		const height = window.innerHeight;

        init().then( animate );
        async function init(){
            //camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.01, 2000 );
            //camera.position.set(0,0,10);

            cameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 1000 );
			cameraOrtho.position.z = 8;

//            scene = new THREE.Scene();
            sceneOrtho = new THREE.Scene();

            runnerTexture = new THREE.TextureLoader().load( './assets/media/sprite/gaming_DinoSprites_walk.png', updateHUDSprites );
            runnerTexture.magFilter = THREE.NearestFilter;
            annie = new TextureAnimator( runnerTexture, 6, 1, 6, 90 ); // texture, #horiz, #vert, #total, duration.                        

            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.autoClear = false;
            container.appendChild( renderer.domElement );
            
            //updateHUDSprites();

            window.addEventListener('resize', onWindowResize);
        }
        function updateHUDSprites() {

            
            material = new THREE.SpriteMaterial( { map: runnerTexture /*, side:THREE.DoubleSide*/ } );
            

            const width = material.map.image.width;
			const height = material.map.image.height;
            
            runner = new THREE.Sprite( material );
            runner.center.set( 0.0, 0.0 );
            runner.scale.set( (width / 10) * 2, (height * 2) / 2, 0 );
            sceneOrtho.add( runner );

            console.log(width/3);

            other();
        }

        function other(){
            const width2 = window.innerWidth / 2;
            const height2 = window.innerHeight / 2;
            runner.position.set( - width2, - height2, 0 );
        }

        function onWindowResize() {
            cameraOrtho.left = - width / 2;
            cameraOrtho.right = width / 2;
            cameraOrtho.top = height / 2;
            cameraOrtho.bottom = - height / 2;
            cameraOrtho.updateProjectionMatrix();

            other();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }
        
        function animate(){
            requestAnimationFrame( animate );            
            var delta = clock.getDelta();
            annie.update(1000 * delta);
            renderer.clear();
			renderer.clearDepth();
			renderer.render( sceneOrtho, cameraOrtho );
        }

        function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration){
            // note: texture passed by reference, will be updated by the update function.

            this.tilesHorizontal = tilesHoriz;
            this.tilesVertical = tilesVert;

            // how many images does this spritesheet contain?
            //  usually equals tilesHoriz * tilesVert, but not necessarily,
            //  if there at blank tiles at the bottom of the spritesheet. 
            this.numberOfTiles = numTiles;
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
            texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

            // how long should each image be displayed?
            this.tileDisplayDuration = tileDispDuration;

            // how long has the current image been displayed?
            this.currentDisplayTime = 0;

            // which image is currently being displayed?
            this.currentTile = 0;

            this.update = function( milliSec ){
                this.currentDisplayTime += milliSec;
                while (this.currentDisplayTime > this.tileDisplayDuration){
                    this.currentDisplayTime -= this.tileDisplayDuration;
                    this.currentTile++;
                    if (this.currentTile == this.numberOfTiles)
                    this.currentTile = 0;
                    var currentColumn = this.currentTile % this.tilesHorizontal;
                    texture.offset.x = currentColumn / this.tilesHorizontal;
                    var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                    texture.offset.y = currentRow / this.tilesVertical;
                }
            }
        }
    </script>

</body>
</html>
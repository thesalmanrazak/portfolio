<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0RNP8J0Q06"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0RNP8J0Q06');
</script>
<body>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('three-js.html');">Back</button>
    </div>

    <div id="loading" class="loading">
        <span>Loading</span>
        <h2>100%</h2>
    </div>

    <script src="./assets/js/jquery.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>    
    <script type="module">
        import * as THREE from 'three';

        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
        import { TWEEN } from 'three/addons/libs/tween.module.min.js';
        import { GroundProjectedSkybox } from 'three/addons/objects/GroundProjectedSkybox.js';

        const container = document.getElementById('container');
        const loading = document.getElementById('loading');

        let camera, controls, scene, renderer;
        let object, car, objectPosition = 0, skybox;
        let tyres = [], rinGroup;
        let spotLight, lightHelper;
        let carlight, hlight1, hlight2, lensflare1, lensflare2;
        let material;
        let textureLoader = new THREE.TextureLoader();
        let textureFlare0 = textureLoader.load( './assets/media/lensflare/lensflare0_alpha.png' );
        let textureFlare3 = textureLoader.load( './assets/media/lensflare/lensflare0_alpha.png' );
        let textureFlare1 = textureLoader.load( './assets/media/lensflare/carlight.png' );
        let cloudMap = textureLoader.load( './assets/media/belfast_sunset_puresky_4k.png' );
        let camX = 0, camY = 0, camZ = 8;
        let grid, sphere;
        let ringSize = 2.0;
        let axehelper = new THREE.AxesHelper(5);

        const basic = {
            axe: false,
        }
        const params = {            
            tonemap: 0.65,
            punctualLightsEnabled: true,
            color: '#dddddd',
            break: 0,
            headlight: 0.1,
            tyrerotate: 0.0,
            tyre: false,            
            shadow: true,            
        };
        const glassparams = {
            color: 0xffffff,
            transmission: 1,
            opacity: 1,
            metalness: 0,
            roughness: 0,
            ior: 1.5,
            thickness: 0.01,
            specularIntensity: 1,
            specularColor: 0xffffff,
            envMapIntensity: 1,
            lightIntensity: 1,
            exposure: 1
        };

        init().then( animate );

        async function init(){
            scene = new THREE.Scene();

            scene_camera();
            
            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.useLegacyLights = false;
            container.appendChild( renderer.domElement );

            renderer.shadowMap.enabled = params.shadow;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = params.tonemap;

            new RGBELoader().load( './assets/hdri/belfast_sunset_puresky_4k.hdr', function ( hdri ) {
                hdri.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = hdri;

                skybox = new GroundProjectedSkybox( hdri );
                skybox.scale.setScalar( 50 );                
                scene.add( skybox );

                scene.environment = hdri;
                //hdri.dispose();
            });


            function loadModel(){
                scene.add( object );
            }

            const manager = new THREE.LoadingManager( loadModel );

            function onProgress( xhr ) {
                if ( xhr.lengthComputable ) {
                    const percentComplete = xhr.loaded / xhr.total * 100; //console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );
                    loading.querySelector('h2').innerHTML = Math.round( percentComplete, 2 ) + '%';
                    if(Math.round( percentComplete, 2 ) == 100){
                        setTimeout(function() {
                            loading.style.transition = '.5s';
                            loading.style.opacity = '0';
                            loading.style.visibility = 'hidden';
                        }, 1250);
                    }
                }
            }
            function onError() {}

            const loader = new GLTFLoader( manager );

            loader.load( './assets/models/car.gltf', function ( obj ) {
                
                // define gltf model and add into scene
                object = obj.scene;
                object.name = "Car";
                object.traverse(function (o) {
                    if (o.isMesh) {
                        o.castShadow = true;
                        o.receiveShadow = false;
                    }
                });
                object.rotation.set( 0, 0, 0 );
                object.position.set( 0, objectPosition, 0 );                

                // push tyres into variable for rotation
                tyres.push( object.getObjectByName( 'wheel_RF' ), object.getObjectByName( 'wheel_RB' ), object.getObjectByName( 'wheel_LB' ), object.getObjectByName( 'wheel_LF' ) );

                tyres[0].rotSpeed = { x: 0, y: 0};
                tyres[1].rotSpeed = { x: 0, y: 0};
                tyres[2].rotSpeed = { x: 0, y: 0};
                tyres[3].rotSpeed = { x: 0, y: 0};

                material = new THREE.MeshPhysicalMaterial( {
					color: glassparams.color,
					metalness: glassparams.metalness,
					roughness: glassparams.roughness,
					ior: glassparams.ior,
					envMapIntensity: glassparams.envMapIntensity,
					transmission: glassparams.transmission,
					specularIntensity: glassparams.specularIntensity,
					specularColor: glassparams.specularColor,
					opacity: glassparams.opacity,
					side: THREE.DoubleSide,
					transparent: true
				} );

                // car glass color and other settings
                object.getObjectByName('glass', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material = material;
                    }
                });

                // car body paint color define
                object.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(params.color);
                        o.material.metalness = 0.8,
					    o.material.roughness = 0,
                        o.material.envMap = scene.background;
                        o.material.envMapIntensity = 0.5;
                        o.castShadow = true;
                        o.receiveShadow = false;
                        o.material.needsUpdate = true;
                    }
                    
                });

                // car break liht color intensity
                object.getObjectByName('break_light', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(0xff000f);
                        o.castShadow = true;
                        o.receiveShadow = true;
                        o.material.envMapIntensity = params.break
                    }
                });
                
                // head light bulb intensity
                object.getObjectByName('headlight_bulb', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(0xffffff);
                        o.castShadow = true;
                        o.receiveShadow = true;
                        o.material.envMapIntensity = params.headlight
                    }
                });

                // right front light
                hlight1 = new THREE.PointLight( 0xffffff, 1.5, 2000 );
                hlight1.color.setHSL( 1, 1, 1 );
                hlight1.position.set( -0.3, 0, 0.012 );

                // left front light
                hlight2 = new THREE.PointLight( 0xffffff, 1.5, 2000 );
                hlight2.color.setHSL( 1, 1, 1 );
                hlight2.position.set( 0.3, 0, 0.012 );

                // add light into car
                object.getObjectByName('headlight_bulb', true).add( hlight1 );
                object.getObjectByName('headlight_bulb', true).add( hlight2 );

                sphere = new THREE.Mesh(
                    new THREE.SphereGeometry( 40, 64, 128 ),
                    new THREE.MeshStandardMaterial( {
                        map: cloudMap,
                        envMapIntensity: 5,
                        side: THREE.DoubleSide,
                        opacity: 0.5,
                        transparent: true
                    } )
                );

                // gui settings
                guis();

                // show shadow of car
                carshadow(1,1000,0x000000,0.4,0);

                // surface rings
                surfaceRings(5,0xffffff,0.05,0.01);

                sceneLight(1,0,2048);

                control();

                grid_add(100, 100, 0xffffff, 0xffffff,0.1,true,true,0.01);

            }, onProgress, onError );

            window.addEventListener('resize', onWindowResize);
        }

        function grid_add(width,height,color1,color2,opacity,depth,transparent,y){
            grid = new THREE.GridHelper( width,height,color1,color2 );
            grid.material.opacity = opacity;
            grid.material.depthWrite = depth;
            grid.material.transparent = transparent;
            grid.position.y = y;
        }

        function guis(){
            const gui = new GUI();

            gui.add( basic, 'axe').name('Axe Helper').onChange(function(val){

                if(val==true){
                    scene.add(axehelper);
                } else {
                    scene.remove(axehelper);
                }
            });

            // folder 1
            const folder1 = gui.addFolder('Glass Material Settings');
            
            folder1.addColor( glassparams, 'color' ).onChange( function () {
                material.color.set( glassparams.color );
            } );
            folder1.add( glassparams, 'transmission', 0, 1, 0.01 ).onChange( function () {
                material.transmission = glassparams.transmission;
            } );
            folder1.add( glassparams, 'opacity', 0, 1, 0.01 ).onChange( function () {
                material.opacity = glassparams.opacity;
            } );
            folder1.add( glassparams, 'metalness', 0, 1, 0.01 ).onChange( function () {
                material.metalness = glassparams.metalness;
            } );
            folder1.add( glassparams, 'roughness', 0, 1, 0.01 ).onChange( function () {
                material.roughness = glassparams.roughness;
            } );
            folder1.add( glassparams, 'ior', 1, 2, 0.01 ).onChange( function () {
                material.ior = glassparams.ior;
            } );
            folder1.add( glassparams, 'thickness', 0, 5, 0.01 ).onChange( function () {
                material.thickness = glassparams.thickness;
            } );
            folder1.add( glassparams, 'specularIntensity', 0, 1, 0.01 ).onChange( function () {
                material.specularIntensity = glassparams.specularIntensity;
            } );
            folder1.addColor( glassparams, 'specularColor' ).onChange( function () {
                material.specularColor.set( glassparams.specularColor );
            } );
            folder1.add( glassparams, 'envMapIntensity', 0, 1, 0.01 ).name( 'envMap intensity' ).onChange( function () {
                material.envMapIntensity = glassparams.envMapIntensity;
            } );
            folder1.close();

            const bodycolor = {
                color: '#ffffff',
                metalness: 0,
                roughness: 0,
                enviromentmap: false,
            }
            // folder 2
            const folder2 = gui.addFolder('Body Paint Settings');

            // toggle scene light
            //folder2.add( params, 'punctualLightsEnabled' ).onChange( toggleLights );
            // car body paint replace
            folder2.addColor( bodycolor, 'color' ).name('Body Paint').onChange(function(val){
                car.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(val);
                        o.castShadow = true;
                        o.receiveShadow = false;
                    }
                });
            });
            folder2.add( bodycolor, 'metalness', 0, 1, 0.01 ).name('Metalness').onChange(function(val){
                car.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.metalness = val,
                        o.material.needsUpdate = true;
                    }
                    
                });
            });
            folder2.add( bodycolor, 'roughness', 0, 1, 0.01 ).name('Roughness').onChange(function(val){
                car.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.roughness = val,
                        o.material.needsUpdate = true;
                    }
                    
                });
            });
            folder2.close();

            const cloud = {
                clouds: false,
            }

            var cloudsX = gui.add( cloud, 'clouds').name('Toggle Clouds').listen().onChange(function(val){
                
                if(val==true){                    
                    scene.add( sphere );
                } else {
                    scene.remove(sphere);
                }
                
            });

            const other = {
                grid: false,                
                headlight: false,
            }

            //const others = gui.addFolder('Other Settings');
            var headlightX = gui.add( other, 'headlight' ).name('Night Head Light').listen().onChange( function(val){

                setChecked("headlight");
                
                if(val===true){

                    // disable controls 
                    controls.enabled = false;

                    // keep controls position into variables
                    controls.position0.x = controls.object.position.x;
                    controls.position0.y = controls.object.position.y;
                    controls.position0.z = controls.object.position.z;

                    // camera fixed position in night
                    new TWEEN.Tween(camera.position).to({ x: 8.0, y: 0.0, z: 0.0}, 3000).delay(10).easing(TWEEN.Easing.Cubic.InOut).start();

                    // camera tone mapping exposure intensity
                    renderer.toneMappingExposure = 0.15;

                    // headlight intensity and lensflare
                    lensflare1 = new Lensflare();
                    lensflare1.addElement( new LensflareElement( textureFlare1, 400, 0, hlight1.color ) );
                    lensflare1.addElement( new LensflareElement( textureFlare1, 60, -0.015 ) );
                    
                    lensflare2 = new Lensflare();
                    lensflare2.addElement( new LensflareElement( textureFlare1, 400, 0, hlight2.color ) );
                    lensflare2.addElement( new LensflareElement( textureFlare1, 60, -0.015 ) );

                    hlight1.add( lensflare1 );
                    hlight2.add( lensflare2 );
                    
                } else if( val === false ) {
                    
                    new TWEEN.Tween(camera.position).to( { x: controls.position0.x, y: controls.position0.y, z: controls.position0.z }, 3000).delay(10).easing(TWEEN.Easing.Cubic.InOut).start();

                    hlight1.remove(lensflare1);
                    hlight2.remove(lensflare2);

                    renderer.toneMappingExposure = 0.65;
                    
                    controls.enabled = true;
                }
                
            } );
            var gridX = gui.add( other, 'grid' ).name('Grid Animation').listen().onChange( function(val){
                
                setChecked("grid");
                
                if(val==true){
                    scene.add( grid );
                    params.tyrerotate = 0.3;
                    object.remove( rinGroup );                    
                } else {
                    scene.remove( grid );
                    params.tyrerotate = 0.0;
                    object.add( rinGroup );
                }
                
            } ); //.onFinishChange( function(value) { console.log('Grid animation Finish Change'); } );

            // toggle check box in same array
            function setChecked( prop ){
                console.log(prop);
                //for (let param in other){
                    //other[param] = false;
                //}                
                //other[prop] = true;
            }

            gui.open();
        }

        function control(){
            controls = new OrbitControls( camera, renderer.domElement ); //controls.minPolarAngle = Math.PI/2;
            controls.maxPolarAngle = Math.PI/2;
            controls.enableDamping = true;
            controls.maxDistance = 100;
            controls.minDistance = 2;
            controls.target.set( 0, 0.5, 0 );
        }

        function surfaceRings(totalRinghs,color,opacity,y){
            rinGroup = new THREE.Group();
            for(let ringCounts = 1; ringCounts <= totalRinghs; ringCounts++){                
                const RingGeometry = new THREE.RingGeometry( ringSize, ringSize + 0.5, 64 ); 
                const RingMaterial = new THREE.MeshBasicMaterial( { color: color, side: THREE.DoubleSide, opacity: opacity, transparent: true } );
                const ring = new THREE.Mesh( RingGeometry, RingMaterial );
                ring.rotation.x = Math.PI/2;
                ring.position.y = y;
                rinGroup.add( ring );
                ringSize = ringSize + 1;
            }
            object.add( rinGroup );
        }

        function carshadow(show,size,color,opacity,y){
            if(show==1){
                const planeGeometry = new THREE.PlaneGeometry( size,size );
                planeGeometry.rotateX( - Math.PI / 2 );
                const planeMaterial = new THREE.ShadowMaterial( { color:color, opacity: opacity } );                
                const plane = new THREE.Mesh( planeGeometry, planeMaterial );
                plane.position.y = y;
                plane.receiveShadow = true;
                object.add(plane);            
            }
        }
        
        function scene_camera(){
            camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.set( camX, camY, camZ );
        }

        function toggleLights( visible ) {
            scene.traverse( function ( object ) {
                if ( object.isLight ) {
                    object.visible = visible;
                }
            } );
            animate();
        }

        function sceneLight(show,showHelper,size){
            if(show == 1){

                scene.add( new THREE.AmbientLight( 0xffffff, 2.05 ) );

                const light = new THREE.DirectionalLight(0xeeeeee, 4);            
                light.position.set(-8,20,10);
                scene.add(light);

                light.castShadow = true;
                light.shadow.mapSize.width = size;
                light.shadow.mapSize.height = size;
                light.shadow.camera.near = 10;
                light.shadow.camera.far = 200;
                light.shadow.focus = 1;

                const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
                hemiLight.color.setHSL( 0.6, 1, 0.6 );
                hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
                hemiLight.position.set( 0, 0, 0 );
                scene.add( hemiLight );

                if(showHelper == 1){
                    scene.add( new THREE.DirectionalLightHelper( light, 5 ) );
                    scene.add( new THREE.HemisphereLightHelper( hemiLight, 5 ) );
                }

            }
        }

        document.addEventListener('keydown', function(event){
            if(event.keyCode == 32){
                console.log('break press');
                object.getObjectByName('break_light', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.envMapIntensity = 5
                    }
                });
            }
        }, false);
        document.addEventListener('keyup', function(event){
            if(event.keyCode == 32){
                console.log('break release');
                object.getObjectByName('break_light', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.envMapIntensity = 0
                    }
                });
            }
        }, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            animate();
        }
        
        function animate() {
            requestAnimationFrame( animate );
            TWEEN.update();
            
            if(controls){
                controls.update();
            }

            if(grid){
                const time = - performance.now() / 1000;
                grid.position.z = + ( time ) % 1;
            }

            if(sphere){
                sphere.rotation.y -= 0.001;
            }

            for ( let i = 0; i < tyres.length; i ++ ) {
                tyres[ i ].rotation.x += params.tyrerotate;
            }

            renderer.render( scene, camera );
        }
    </script>

</body>
</html>
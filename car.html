<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
<link rel="icon" type="image/png" sizes="64x64" href="./assets/media/favicon.png">
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HR8J8853HV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HR8J8853HV');
</script>
<body>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('three-js.html');">Back</button>
    </div>
    <!--
    <div id="loading" class="loading">
        <span>Loading</span>
        <h2></h2>
    </div>
    -->
    <script src="./assets/js/jquery.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>    
    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from './assets/jsm/controls/OrbitControls.js';
        import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
		import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        THREE.ColorManagement.enabled = false;

        const container = document.getElementById('container');
        const loading = document.getElementById('loading');

        let cube, scene, camera, renderer, controls, object, skybox, tyres = [], stats, groundMirror, hemiLight, spotLight, shadowplane, mshStdFloor;
        const group = new THREE.Group();

        const params = {            
            color: '#7821c0',
            floor: '#7821c0',
            metalness: 0.15,
            roughness: 0.05,
            mirror: false,
            rectanglelight: false,
            spotlight: false,
        };

        init().then( animate );

        async function init(){
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x000000 ); // 7821c0 // 411367
            scene.fog = new THREE.FogExp2( 0xff0000, 0.0025 );

            const axe = new THREE.AxesHelper(5);
            //scene.add(axe);

            camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set( 6, 0, 0 );
            
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
            renderer.setSize( window.innerWidth, window.innerHeight );            
            container.appendChild( renderer.domElement );
    
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;


            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            
            RectAreaLightUniformsLib.init();

            function loadModel(){
                scene.add( object );
            }

            const manager = new THREE.LoadingManager( loadModel );

            function onProgress( xhr ) {
                if ( xhr.lengthComputable ) {
                    const percentComplete = xhr.loaded / xhr.total * 100;
                    console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );
                    /*
                    loading.querySelector('h2').innerHTML = Math.round( percentComplete, 2 ) + '%';
                    if(Math.round( percentComplete, 2 ) == 100){
                        setTimeout(function() {
                            loading.style.transition = '.5s';
                            loading.style.opacity = '0';
                            loading.style.visibility = 'hidden';
                        }, 1250);
                    }
                    */
                }
            }
            function onError() {}

            const loader = new GLTFLoader( manager );

            loader.load( './assets/models/car.gltf', function ( obj ) {
                
                // define gltf model and add into scene
                object = obj.scene;
                object.traverse( function( o ) {
                    if ( o.isMesh ) {
                        o.castShadow = true;
                    }
                } );
                object.name = "Car";
                
                // body paint
                object.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material = new THREE.MeshPhysicalMaterial({
                            color: new THREE.Color( params.color ),
                            metalness: params.metalness,
                            roughness: params.roughness,
                        });
                        o.material.needsUpdate = true;
                    }                    
                });

                // car glass color and other settings
                object.getObjectByName('glass', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material = new THREE.MeshPhysicalMaterial( {
                            color: 0xffffff,
                            opacity: 0.25,
                            transmission: 1,
                            //metalness: 0,
                            //roughness: 0,
                            ior: 0.25,
                            thickness: 1.5,
                            //envMapIntensity: 0.1,
                            //specularIntensity: 0.2,
                            //side: THREE.DoubleSide,
                            transparent: true
                        } );
                    }
                });

                // break light
                object.getObjectByName('break_light', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(0xff0000);
                        //o.castShadow = true;
                        //o.receiveShadow = false;
                        o.material.envMapIntensity = 1;
                    }
                });

                spotlight(0xffffff,0.75,0,20,-5,0,1);
                spotlight(0xffffff,0.75,0,20,5,0,1);
                spotlight(0xffffff,0.75,0,1,5,0,0);
                spotlight(0xffffff,0.75,0,1,-5,0,0);

                // shadow
                shadow(-0,0.5,50);
                
                guis();

                //mirror(0xaaaaaa,1,200);

                rectLight( 0xffffff, 3, 5, 3, -10, 5, 0, 0 ); // left
                rectLight( 0xffffff, 3, 5, 3, 10, 5, 0, 0 ); // right
                rectLight( 0xffffff, 1, 30, 30, 0, 10, 0, 0 ); // top

                control();

            }, onProgress, onError );

            stats = new Stats();
			//document.body.appendChild( stats.dom );

            window.addEventListener('resize', onWindowResize);
        }

        function shadow(y,opacity,size){

            
            const geoFloor = new THREE.BoxGeometry( size, 0.1, size );
            const matStdFloor = new THREE.MeshStandardMaterial( { color: params.floor, roughness: 0.1, metalness: 0.05 } );// 0x7821c0
            mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );
            mshStdFloor.position.y = -0.5;
            scene.add( mshStdFloor );
            

            const shadowgeometry = new THREE.PlaneGeometry( size, size );
            shadowgeometry.rotateX( - Math.PI / 2 );

            const shadowmaterial = new THREE.ShadowMaterial();
            shadowmaterial.opacity = opacity;

            shadowplane = new THREE.Mesh( shadowgeometry, shadowmaterial );
            shadowplane.position.y = y;
            shadowplane.receiveShadow = true;
            scene.add(shadowplane);
        }

        function mirror(color,clipBias,size){
            groundMirror = new Reflector( new THREE.PlaneGeometry( size, size, size, size ), {
                clipBias: clipBias,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: color,
            } );
            groundMirror.position.y = -0.05;
            groundMirror.rotateX( - Math.PI / 2 );
            groundMirror.lookAt( object.position ); // scene.add( groundMirror );
        }

        function guis(){
            const gui = new GUI();
            gui.addColor( params, 'color' ).name('Body Paint').onChange(function(val){
                object.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(val);
                        o.castShadow = true;
                        o.receiveShadow = false;
                    }
                });
            });
            gui.addColor( params, 'floor' ).name('Floor Color').onChange(function(val){
                
                mshStdFloor.traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.color = new THREE.Color(val);
                        //o.castShadow = true;
                        //o.receiveShadow = false;
                    }
                });
            });
            gui.add( params, 'metalness', 0, 0.5, 0.01 ).name('Metalness').onChange(function(val){
                object.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.metalness = val,
                        o.material.needsUpdate = true;
                    }
                    
                });
            });
            gui.add( params, 'roughness', 0, 0.4, 0.01 ).name('Roughness').onChange(function(val){
                object.getObjectByName('bodypaint', true).traverse ( ( o ) => {
                    if ( o.isMesh ) {
                        o.material.roughness = val,
                        o.material.needsUpdate = true;
                    }
                    
                });
            });
            /*
            gui.add( params, 'mirror' ).name('Ground Mirror').onChange(function(val){
                if(val==true){
                    scene.add(groundMirror);
                } else {
                    scene.remove(groundMirror);
                }
            });
            gui.add( params, 'rectanglelight').name('Rectangle Lights').onChange( function(val){
                
                if(val==true){
                    scene.add( group );                    
                } else {
                    scene.remove( group );
                }

            });
            gui.add( params, 'spotlight').name('Spot Light').onChange( function(val){
                if(val==true){
                    scene.add( spotLight );
                    scene.add( shadowplane );
                } else {
                    scene.remove( spotLight );
                    scene.remove( shadowplane );
                }
            });
            */
        }

        function spotlight(color,intensity,x,y,z,show,shadow){
            
            spotLight = new THREE.SpotLight( color, intensity );
            spotLight.position.set( x, y, z );
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 1;
            spotLight.decay = 2;
            spotLight.distance = 200;

            spotLight.shadow.mapSize.width = 4096;
            spotLight.shadow.mapSize.height = 4096;
            spotLight.shadow.camera.near = 0.1;
            spotLight.shadow.camera.far = 500;
            spotLight.shadow.focus = 30;
            scene.add( spotLight );

            if(shadow==1){
                spotLight.castShadow = true;
            }

            if(show==1){
                const lightHelper = new THREE.SpotLightHelper( spotLight );
                scene.add( lightHelper );

                const camerahelper = new THREE.CameraHelper( spotLight.shadow.camera );
                //scene.add( camerahelper );
            }

        }

        function hemi(show){
            hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
            hemiLight.color.setHSL( 1.0, 1.0, 1.0 );
            hemiLight.groundColor.setHSL( 1, 1, 1 );
            hemiLight.position.set( 0, -0.05, 0 );
            //scene.add( hemiLight );

            if( show == 1 ){
                const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 5 );
                scene.add( hemiLightHelper );
            }
        }

        function rectLight(color,intensity,width,height,x,y,z,show){
            const rectLight = new THREE.RectAreaLight( color, intensity, width, height );
            rectLight.position.set( x, y, z );
            rectLight.lookAt( 0, 0, 0 );
            group.add( rectLight );
            scene.add( group );
            if(show == 1){
                scene.add( new RectAreaLightHelper( rectLight ) );
            }
        }

        function control(){
            controls = new OrbitControls( camera, renderer.domElement ); //controls.minPolarAngle = Math.PI/2;
            controls.maxPolarAngle = Math.PI/2;
            controls.enableDamping = true;
            controls.maxDistance = 20;
            controls.minDistance = 5;            
            controls.target.set( 0, 0.5, 0 );
            controls.update();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            animate();
        }
        
        function animate() {
            requestAnimationFrame( animate );
            
            if(controls){
                controls.update();
            }            
            if(stats){
                stats.update();
            }
            render();            
        }
    
        function render(){
            renderer.render( scene, camera );
        }
    </script>

</body>
</html>
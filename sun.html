<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<body>

    <script id="frag1" type="x-shader/x-fragment">
        uniform float iGlobalTime;
        uniform vec2 resolution;
        uniform vec4      iMouse;
        uniform sampler2D iChannel0;
        varying vec2 fragCoord;
        varying vec2 vUv;
        vec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }
        vec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }
        vec3 dmul( vec3 a, vec3 b )  {
            float r = length(a);
            b.xy=cmul(normalize(a.xy), b.xy);
            b.yz=cmul(normalize(a.yz), b.yz);
            return r*b;
        }
        vec3 pow4( vec3 z){
            z=dmul(z,z);return dmul(z,z);
        }
        vec3 pow3( vec3 z){
            float r2 = dot(z,z);
            vec2 a = z.xy;a=csqr(a)/dot( a,a);
            vec2 b = z.yz;b=csqr(b)/dot( b,b); 
            vec2 c = z.xz;c=csqr(c)/dot( c,c);
            z.xy = cmul(a,z.xy);   
            z.yz = cmul(b,z.yz);      
            z.xz = cmul(c,z.xz);
            return r2*z;
        }
        mat2 rot(float a) {
            return mat2(cos(a),sin(a),-sin(a),cos(a));  
        }
        float zoom=4.;
        float field(in vec3 p) {
            float res = 0.;
            vec3 c = p;
            for (int i = 0; i < 10; ++i) {
                p = abs(p) / dot(p,p) -1.;
                p = dmul(p,p)+.7;
                res += exp(-6. * abs(dot(p,c)-.15));
            }
            return max(0., res/3.);
        }
        vec3 raycast( in vec3 ro, vec3 rd )
        {
            float t = 6.0;
            float dt = .05;
            vec3 col= vec3(0.);
            for( int i=0; i<64; i++ )
            {
                float c = field(ro+t*rd);               
                t+=dt/(.35+c*c);
                c = max(5.0 * c - .9, 0.0);
                col = .97*col+ .08*vec3(0.5*c*c*c, .6*c*c, c);
            }
            return col;
        }
        void main()
        {
            float time = iGlobalTime;
            vec2 q = fragCoord.xy / resolution.xy;
            vec2 p = -1.0 + 2.0 * q;
            p.x *= resolution.x/resolution.y;
            vec2 m = vec2(0.);
            if( iMouse.z>0.0 )m = iMouse.xy/resolution.xy*3.14;
            m-=.5;
            vec3 ro = zoom*vec3(1.);
            ro.yz*=rot(m.y);
            ro.xz*=rot(m.x+ 0.1*time);
            vec3 ta = vec3( 0.0 , 0.0, 0.0 );
            vec3 ww = normalize( ta - ro );
            vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
            vec3 vv = normalize( cross(uu,ww));
            vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );
            vec3 col = raycast(ro,rd);
            col =  .5 *(log(1.+col));
            col = clamp(col,0.,1.);
            gl_FragColor = vec4( sqrt(col), 1.0 );
        }
    </script>
    <script id="frag2" type="x-shader/x-fragment">
        float random(in float x){
            return fract(sin(x)*43758.5453);
        }
        
        float random(in vec2 st){
            return fract(sin(dot(st.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }
        
        float randomChar(in vec2 outer,in vec2 inner){
            float grid = 5.;
            vec2 margin = vec2(.2,.05);
            float seed = 23.;
            vec2 borders = step(margin,inner)*step(margin,1.-inner);
            return step(.5,random(outer*seed+floor(inner*grid))) * borders.x * borders.y;
        }
        
        vec3 matrix(in vec2 st){
            float rows = 50.0;
            vec2 ipos = floor(st*rows)+vec2(1.,0.);
        
            ipos += vec2(.0,floor(time*20.*random(ipos.x)));
        
            vec2 fpos = fract(st*rows);
            vec2 center = (.5-fpos);
        
            float pct = random(ipos);
            float glow = (1.-dot(center,center)*3.)*2.0;
        
            return vec3(randomChar(ipos,fpos) * pct * glow);
        }
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord ){
            vec2 st = fragCoord.xy / resolution.xy;
            st.y *= resolution.y/resolution.x;
        
            fragColor = vec4(matrix(st),1.0);
        }
    </script>
    <script id="general" type="x-shader/x-vertex">
        attribute vec3 in_Position;
        varying vec2 fragCoord;
        varying vec2 vUv; 
        void main()
        {
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
            fragCoord = position.xy;
        }
    </script>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('threejs.html');">Back</button>
    </div>

    <script src="./assets/js/jquery.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>

    <script>
        const fragmentShader = `
            #include <common>
            
                #ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

vec3 vec_tovec3(float a) {
  return vec3(a, a, a);
}
vec3 noise_vec3_yzx(vec3 self) {
  return vec3(self.y, self.z, self.x);
}
vec3 noise_vec2_xyx(vec2 self) {
  return vec3(self.x, self.y, self.x);
}
vec2 sincos(float x) {
  return vec2(sin(x), cos(x));
}
float noise_hash1_2(vec2 v) {
  vec3 v3 = noise_vec2_xyx(v);
  v3 = fract((v3 * 0.1031));
  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));
  return fract(((v3.x + v3.y) * v3.z));
}
float noise_hash1_3(vec3 v) {
  vec3 v3 = v;
  v3 = fract((v3 * 0.1031));
  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));
  return fract(((v3.x + v3.y) * v3.z));
}
float noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f) {
  vec3 u = ((f * f) * (3.0 - (2.0 * f)));
  vec3 u1 = (1.0 - u);
  return ((((((a1 * u1.x) + (b1 * u.x)) * u1.y) + (((c1 * u1.x) + (d1 * u.x)) * u.y)) * u1.z) + (((((a2 * u1.x) + (b2 * u.x)) * u1.y) + (((c2 * u1.x) + (d2 * u.x)) * u.y)) * u.z));
}
float noise_noise_white_1(vec2 p) {
  return noise_hash1_2(p);
}
float noise_noise_value_1(vec3 p) {
  vec3 i = floor(p);
  vec3 f = fract(p);
  vec3 j = (i + 1.0);
  float a1 = noise_hash1_3(i);
  float b1 = noise_hash1_3(vec3(j.x, i.y, i.z));
  float c1 = noise_hash1_3(vec3(i.x, j.y, i.z));
  float d1 = noise_hash1_3(vec3(j.x, j.y, i.z));
  float a2 = noise_hash1_3(vec3(i.x, i.y, j.z));
  float b2 = noise_hash1_3(vec3(j.x, i.y, j.z));
  float c2 = noise_hash1_3(vec3(i.x, j.y, j.z));
  float d2 = noise_hash1_3(j);
  return noise_noisemix3(a1, b1, c1, d1, a2, b2, c2, d2, f);
}
float map(vec3 p) {
  return (length(p) - 0.6);
}
float ray_march(vec3 ro, vec3 rd) {
  float t = 0.0;
  for(int i = 0; i < 128; i++) {
    vec3 p = (ro + (t * rd));
    float d = map(p);
    if(d <= 0.0001) {
      return t;
    }
    t = (t + d);
    if(t > 10.0) {
      return -1.0;
    }
  }
  return -1.0;
}
vec3 get_normal(vec3 p) {
  return normalize(((((vec3(1.0, -1.0, -1.0) * map((p + vec3(0.0001, -0.0001, -0.0001)))) + (vec3(-1.0, -1.0, 1.0) * map((p + vec3(-0.0001, -0.0001, 0.0001))))) + (vec3(-1.0, 1.0, -1.0) * map((p + vec3(-0.0001, 0.0001, -0.0001))))) + (vec3(1.0, 1.0, 1.0) * map((p + vec3(0.0001, 0.0001, 0.0001))))));
}
float fbm3(vec3 p) {
  float a = 1.0;
  float t = 0.0;
  t = (t + (a * noise_noise_value_1(p)));
  a = (a * 0.5);
  p = ((2.0 * p) + 100.0);
  t = (t + (a * noise_noise_value_1(p)));
  a = (a * 0.5);
  p = ((2.0 * p) + 100.0);
  t = (t + (a * noise_noise_value_1(p)));
  a = (a * 0.5);
  p = ((2.0 * p) + 100.0);
  t = (t + (a * noise_noise_value_1(p)));
  a = (a * 0.5);
  p = ((2.0 * p) + 100.0);
  t = (t + (a * noise_noise_value_1(p)));
  a = (a * 0.5);
  p = ((2.0 * p) + 100.0);
  t = (t + (a * noise_noise_value_1(p)));
  return t;
}
vec3 planet_palette(float x) {
  vec3 col = vec3(0.1, 0.6, 0.9);
  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));
  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));
  return col;
}
vec3 planet_color(vec3 p) {
  p = (p * 2.0);
  float t = time;
  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));
  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));
  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);
  vec3 col = planet_palette(r.y);
  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));
  col = clamp(col, 0.0, 1.0);
  return col;
}
vec3 shade(vec3 rd, vec3 p) {
  vec3 normal = get_normal(p);
  float ambient_dif = 0.03;
  vec3 dif = vec_tovec3(ambient_dif);
  vec3 sun_dir = vec3(0.0, 0.0, 1.0);
  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);
  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);
  dif = (dif + (sun_col * sun_dif));
  vec3 mate = (planet_color(p) * 0.4);
  vec3 col = (mate * dif);
  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);
  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));
  col = (col * (1.0 - fres));
  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));
  return col;
}
vec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {
  vec2 sc = sincos(tilt);
  vec3 vup = normalize(vec3(sc.x, sc.y, 0.0));
  vec3 w = normalize((lookat - lookfrom));
  vec3 u = cross(w, vup);
  vec3 v = cross(u, w);
  float wf = (1.0 / tan(((vfov * 3.14159265) / 360.0)));
  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));
}
float expstep(float x, float k) {
  return exp(((k * x) - k));
}
vec3 get_background(vec3 rd) {
  vec3 sun_dir = vec3(0.0, 0.0, 1.0);
  float sun_dif = dot(rd, sun_dir);
  vec3 col = (vec3(1.0, 0.9, 0.9) * expstep(sun_dif, 600.0));
  col = (col + (vec3(1.0, 1.0, 0.1) * expstep(sun_dif, 100.0)));
  col = (col + (vec3(1.0, 0.7, 0.7) * expstep(sun_dif, 50.0)));
  col = (col + (vec3(1.0, 0.6, 0.05) * expstep(sun_dif, 10.0)));
  return col;
}
vec3 color_tonemap_aces(vec3 col) {
  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);
}
vec3 color_saturate(vec3 col, float sat) {
  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));
  return (grey + (sat * (col - grey)));
}
vec3 color_tone_1(vec3 col, float gain, float lift, float invgamma) {
  col = pow(col, vec_tovec3(invgamma));
  return (((gain - lift) * col) + lift);
}
vec3 color_gamma_correction(vec3 col) {
  return pow(col, vec_tovec3(0.454545455));
}
vec3 vignette(vec3 col, vec2 coord, float strength, float amount) {
  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));
}
vec3 dither(vec3 col, vec2 coord, float amount) {
  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);
}
vec3 sun_glare(vec3 rd) {
  vec3 sun_dir = vec3(0.0, 0.0, 1.0);
  vec3 glare_col = vec3(1.0, 0.6, 0.2);
  return (glare_col * pow(max(dot(sun_dir, rd), 0.0), 2.0));
}
void main() {
  vec2 res = vec2(resolution.x, resolution.y);
  vec2 mouse = vec2((mouse.x / resolution.x), (mouse.y / resolution.y));
  vec2 coord = ((2.0 * (gl_FragCoord.xy - (res * 0.5))) / resolution.y);
  float theta = ((1.88495559 + (time * 0.2)) + (6.28318531 * mouse.x));
  vec3 lookat = vec3(0.0, 0.0, 0.0);
  vec2 sc = (sincos(theta) * 2.0);
  vec3 ro = vec3(sc.x, 0.5, sc.y);
  vec3 rd = perspective_camera(ro, lookat, 0.0, 50.0, coord);
  float t = ray_march(ro, rd);
  vec3 p = (ro + (rd * t));
  vec3 col = get_background(rd);
  if(t >= 0.0) {
    col = shade(rd, p);
  }
  col = (col + (0.2 * sun_glare(rd)));
  col = color_tonemap_aces(col);
  col = color_tone_1(col, 1.7, 0.002, 1.2);
  col = color_saturate(col, 0.9);
  col = color_gamma_correction(col);
  col = vignette(col, (gl_FragCoord.xy / res), 0.25, 0.7);
  col = dither(col, gl_FragCoord.xy, 0.01);
  gl_FragColor = vec4(col.x, col.y, col.z, 1.0);
}

        `;
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';        
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        import { } from 'three/addons/postprocessing/EffectComposer.js';
        import { } from 'three/addons/postprocessing/RenderPass.js';
        import { } from 'three/addons/postprocessing/FilmPass.js';
        import { } from 'three/addons/postprocessing/BloomPass.js';
        import { } from 'three/addons/shaders/CopyShader.js';
        import { } from 'three/addons/shaders/ConvolutionShader.js';
        import { } from 'three/addons/shaders/FilmShader.js';
        import { } from 'three/addons/postprocessing/ShaderPass.js';

        const container = document.getElementById('container');

        var camera, scene, renderer, controls;
        var start = Date.now();
        let material, mat;
        let uniforms, vertex, meme,plane, sphare, me;

        init();

        function init(){
            scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x101010 );
		
			// camera + controls
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 100;

            uniforms = {
                time: { value: 0 },
                resolution:  { value: new THREE.Vector3() },
            };
            const ma = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                fragmentShader, uniforms,
                side : THREE.DoubleSide,
                opacity : 0.4,
                transparent : true,
                depthWrite  : false,
            } );

            
            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            container.appendChild( renderer.domElement );
            
            sphare = new THREE.PlaneGeometry( window.innerWidth, window.innerHeight );
            //sphare = new THREE.SphereGeometry( 35, 55, 64 );
            sphare.startTime = Date.now();
            sphare.uniforms = uniforms;
            me = new THREE.Mesh( sphare, ma );
            me.position.set(0,0,0);
            scene.add( me );

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            animate();
        }
        
        function animate(time) {
            time *= 0.001; //convert to seconds            
			renderer.render( scene, camera );
            requestAnimationFrame( animate );
            const canvas = renderer.domElement;

            //me.rotation.z -= 0.001;
            //me.rotation.x += 0.05;

            uniforms.resolution.value.set(window.innerWidth, window.innerHeight, 1);
            var elapsedMilliseconds = Date.now() - sphare.startTime;
            var elapsedSeconds = elapsedMilliseconds / 1000.;
            sphare.uniforms.time.value = time;
        }
        
        animate();

        $(function(){
            
            $('.camera-positions button').on('click', function(){
                var posX = $(this).data('x');
                var posY = $(this).data('y');
                var posZ = $(this).data('z');
                new TWEEN.Tween(camera.position).to({x: posX, y: posY, z: posZ}).start();
            })
            
            $('.shoes-colors div').each(function(index, elem){
                $(this).css('background',$(this).data('hex'));
            });

            $('.shoes-colors div').on('click', function(){
                $('.colors div').removeClass('active');
                $(this).addClass('active');
                var bg = $(this).data('hex');            
                var colorValue = parseInt ( bg.replace("#","0x"), 16 );
                var colored = new THREE.Color( colorValue );                
                scene.background = colored;
            });

            $('.shoes-texture div').each(function(){
                $(this).css({'background':'url('+ $(this).data('image') +') center center no-repeat', 'background-size':'cover'});
            });

            $('.shoes-texture div').on('click', function(){
                var newTexture = $(this).data('image');
                shoe.traverse(function (node) {                    
                    if (node.isMesh) {
                        node.material.map = new THREE.TextureLoader().load(newTexture, texture => {
                            texture.flipY = false
                        });
                        node.castShadow = true;
                        node.receiveShadow = false;
                    }
                });
                shoe.updateMatrix();
            });

        });

    </script>

</body>
</html>
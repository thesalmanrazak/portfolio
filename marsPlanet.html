<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<body>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('threejs.html');">Back</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        const container = document.getElementById('container');

        const loader = new THREE.TextureLoader();
        let mars, earth, moon, scene, camera, renderer, controls, stars;
        let pointLight;
        let moonTexture, geometry, material;
        let light, directionalLight, helper;
        let marsTexture = './assets/media/planet/5672_marsmap2k.jpg';
        let marsDisplacementTexture = './assets/media/planet/5672_mars_2k_topo.jpg';
        let marsBumpTexture = './assets/media/planet/5672_mars_2k_normal.jpg';

        function init(){
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x05060b );
            
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 1, 10000 );
            camera.position.z = 35; //scene.add( new THREE.CameraHelper( camera ) );
            
            renderer = new THREE.WebGLRenderer({ antialias: true});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            pointLight = new THREE.PointLight( 0xffffff, 5, 100 );
            pointLight.position.set( 0, 50, 50 );
            scene.add( pointLight );
            const pointLightHelper = new THREE.PointLightHelper( pointLight, 1 );
            scene.add( pointLightHelper );
            
            geometry = new THREE.SphereGeometry( 16, 128, 64 );
            material = new THREE.MeshStandardMaterial({
                map : loader.load( marsTexture ),
                bumpMap: loader.load( marsBumpTexture ),
                bumpScale: 0.4,
                fog: true
            });
            mars = new THREE.Mesh( geometry, material );
            scene.add(mars);

            new FontLoader().load('./assets/fonts/Sigmar_Regular.json', function ( font ) {

                const matDark = new THREE.LineBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } );

                const matLite = new THREE.MeshBasicMaterial( {
                    color: 0xffffff,
                    transparent: true,
                    side: THREE.DoubleSide
                } );

                const message = 'MARS';
                const shapes = font.generateShapes( message, 3.5 );
                const geometry = new THREE.ShapeGeometry( shapes );
                geometry.computeBoundingBox();
                const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
                const yMid = - 0.5 * ( geometry.boundingBox.max.y - geometry.boundingBox.min.y );
                geometry.translate( xMid, yMid, 0 );

                const text = new THREE.Mesh( geometry, matLite );
                text.position.z = 20;
                scene.add( text );

                const holeShapes = [];

                for ( let i = 0; i < shapes.length; i ++ ) {

                    const shape = shapes[ i ];

                    if ( shape.holes && shape.holes.length > 0 ) {

                        for ( let j = 0; j < shape.holes.length; j ++ ) {

                            const hole = shape.holes[ j ];
                            holeShapes.push( hole );

                        }

                    }

                }

                shapes.push.apply( shapes, holeShapes );

                const lineText = new THREE.Object3D();

                for ( let i = 0; i < shapes.length; i ++ ) {

                    const shape = shapes[ i ];

                    const points = shape.getPoints();
                    const geometry = new THREE.BufferGeometry().setFromPoints( points );

                    geometry.translate( xMid, 0, 0 );

                    const lineMesh = new THREE.Line( geometry, matDark );
                    lineText.add( lineMesh );

                }

                //scene.add( lineText );

            }, function ( xhr ) {
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
            }, function ( err ) {
                console.log( 'An error happened' );
            });
            
            starsGeometry();

            controls = new OrbitControls( camera, renderer.domElement ); controls.enableZoom = false; controls.update();

            window.addEventListener('resize', onWindowResize);
        }

        function starsGeometry(){
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for(let i = 0; i < 20000; i++){
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x,y,z);
            }
            starGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute(starVertices, 3) );
            stars = new THREE.Points( starGeometry, new THREE.PointsMaterial({
                color: 0xffffff, /* map: new THREE.TextureLoader().load('./assets/media/lensflare/lensflare0_alpha.png'), */
            }) );
            scene.add(stars);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();

        var r = 50;
        var theta = 0;
        var dTheta = 2 * Math.PI / 1000;

        function animate() {
            requestAnimationFrame( animate ); // moon.rotation.x += 0.001; moon.rotation.y += 0.001;
            //controls.update();
            theta -= dTheta;

            mars.rotation.y += 0.0005;
            stars.rotation.y -= 0.0002;
            //pointLight.position.x = r * Math.cos(theta);
            //pointLight.position.z = r * Math.sin(theta);

            renderer.render( scene, camera );
        }
        
        animate();
    </script>

</body>
</html>
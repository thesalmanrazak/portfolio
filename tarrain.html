<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salman Razak :|: Being creative mean be different...</title>
    <link rel="stylesheet" href="./assets/css/three.css">
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0RNP8J0Q06"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0RNP8J0Q06');
</script>
<body>

    <div id="container">
        <button type="button" class="backBtn" onclick="window.location.replace('threejs.html');">Back</button>
    </div>

    <script src="./assets/js/jquery.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./assets/build/three.module.js",
                "three/addons/": "./assets/jsm/"
            }
        }
    </script>    
    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';

        import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        let container, stats;
        let camera, controls, scene, renderer;
        let mesh, texture;
        let theWidth = 150; // 256;

        const worldWidth = theWidth, worldDepth = theWidth;
        const clock = new THREE.Clock();

        init().then( animate );

        async function init() {

            container = document.getElementById( 'container' );

            camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );

            scene = new THREE.Scene();
            //scene.background = new THREE.Color( 0xeeeeff );
            //scene.fog = new THREE.FogExp2( 0xeeeeff, 0.0025 );

            const data = generateHeight( worldWidth, worldDepth );

            camera.position.set( 100, 1000, - 1000 );
            camera.lookAt( - 100, 810, - 1000 );

            const geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );
            geometry.rotateX( - Math.PI / 2 );
            
            const vertices = geometry.attributes.position.array;

            for ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
                vertices[ j + 1 ] = data[ i ] * 10;
            }
            /*
            texture = new THREE.CanvasTexture( generateTexture( data, worldWidth, worldDepth ) );
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            */
            const texture2 = new THREE.TextureLoader().load('./assets/media/terrain/map.png', function(tex){
                tex.flipY = false;
                //tex.generateMipmaps = false;
                //tex.minFilter = THREE.LinearFilter;
                //tex.magFilter = THREE.LinearFilter;
                //tex.needsUpdate = true;
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                tex.colorSpace = THREE.SRGBColorSpace;
            });
            const bump = new THREE.TextureLoader().load('./assets/media/terrain/bump.png', function(tex){
                tex.flipY = false;
                //tex.generateMipmaps = false;
                //tex.minFilter = THREE.LinearFilter;
                //tex.magFilter = THREE.LinearFilter;
                //tex.needsUpdate = true;
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                tex.colorSpace = THREE.SRGBColorSpace;
            });

            mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( {
                map: texture2,
                bumpMap: bump,
                bumpScale: 0.5,
            } ) );
            scene.add( mesh );

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            controls = new FirstPersonControls( camera, renderer.domElement );
            controls.movementSpeed = 450;
            controls.lookSpeed = 0.1;

            stats = new Stats();
            container.appendChild( stats.dom );


            lights(1,0);

            window.addEventListener( 'resize', onWindowResize );

        }

        function lights(show,helper){
            if(show == 1){
                
                scene.add( new THREE.AmbientLight( 0xffffff, 0.5 ));

                const spotLight = new THREE.SpotLight( 0xffffff, 1 );
                spotLight.position.set( 0, 10, 7 );
                spotLight.angle = Math.PI / 6;
                spotLight.penumbra = 5;
                spotLight.decay = 2;
                spotLight.distance = 100;

                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 2048;
                spotLight.shadow.mapSize.height = 2048;
                spotLight.shadow.camera.near = 10;
                spotLight.shadow.camera.far = 200;
                spotLight.shadow.focus = 1;
                scene.add( spotLight );

                if(helper == 1){
                    const lightHelper = new THREE.SpotLightHelper( spotLight );
                    scene.add( lightHelper );
                }
            }
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            controls.handleResize();

        }

        function generateHeight( width, height ) {

            let seed = Math.PI / 4;
            window.Math.random = function () {

                const x = Math.sin( seed ++ ) * 10000;
                return x - Math.floor( x );

            };

            const size = width * height, data = new Uint8Array( size );
            const perlin = new ImprovedNoise(), z = Math.random() * 100;

            let quality = 1;

            for ( let j = 0; j < 4; j ++ ) {

                for ( let i = 0; i < size; i ++ ) {

                    const x = i % width, y = ~ ~ ( i / width );
                    data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );

                }

                quality *= 5;

            }

            return data;

        }

        function generateTexture( data, width, height ) {

            let context, image, imageData, shade;

            const vector3 = new THREE.Vector3( 0, 0, 0 );

            const sun = new THREE.Vector3( 1, 1, 1 );
            sun.normalize();

            const canvas = document.createElement( 'canvas' );
            canvas.width = width;
            canvas.height = height;

            context = canvas.getContext( '2d' );
            context.fillStyle = '#000';
            context.fillRect( 0, 0, width, height );

            image = context.getImageData( 0, 0, canvas.width, canvas.height );
            imageData = image.data;

            for ( let i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

                vector3.x = data[ j - 2 ] - data[ j + 2 ];
                vector3.y = 2;
                vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
                vector3.normalize();

                shade = vector3.dot( sun );

                imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
                imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
                imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );

            }

            context.putImageData( image, 0, 0 );

            // Scaled 4x

            const canvasScaled = document.createElement( 'canvas' );
            canvasScaled.width = width * 4;
            canvasScaled.height = height * 4;

            context = canvasScaled.getContext( '2d' );
            context.scale( 4, 4 );
            context.drawImage( canvas, 0, 0 );

            image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
            imageData = image.data;

            for ( let i = 0, l = imageData.length; i < l; i += 4 ) {

                const v = ~ ~ ( Math.random() * 5 );

                imageData[ i ] += v;
                imageData[ i + 1 ] += v;
                imageData[ i + 2 ] += v;

            }

            context.putImageData( image, 0, 0 );

            return canvasScaled;

        }

        function animate() {
            requestAnimationFrame( animate );
            render();
            stats.update();
        }

        function render() {
            controls.update( clock.getDelta() );
            renderer.render( scene, camera );
        }

    </script>

</body>
</html>